# Big-O 표기법
알고리즘이 얼마나 빠르고 얼마나 많은 공간을 차지하는지 아는것은 어떤 작업을 할 때 적절한 알고리즘을 고를 수 있게 해줄 수 있어 매우 유용합니다.

Big-O표기법은 알고리즘의 실행시간 그리고 사용되는 메모리의 양을대략적으로 알 수 있게 해줍니다. 누군가가 “이 알고리즘은 **O(n^2)**라는 최악의 실행시간을 가지며 **O(n)**만크의 공간을 사용한다” 라고 한다면 이 알고리즘은 느리지만 많은양의 부가 메모리가 필요하지 않다는 것을 의미합니다

알고리즘의 Big-O를 파악하는 것은 대게 수학적 분석을 통해 이루어집니다. 여기서 수학적인 부분은 건너뛰지만, 값들이 어떻게 다른 의미를 가지고 있는지를 아는게 좋습니다. 아래의 표에서 볼 수 있는 **n**은 접근하는 데이터의 개수를 의미합니다. 예를들어 100개의 아이템이 있는 배열을 정렬한다면 **n = 100**입니다.


Big-O | 이름 | 설명
------| ---- | ----
**O(1)** | constant | **그냥 최고입니다.** 이 알고리즘은 얼만큼에 데이터가 있던간에 항상 같은 양의 시간을 요구합니다. 예: 인덱스를 이용하여 배열로부터 값을 얻는 작업
**O(log n)** | logarithmic | **매우 좋은 편입니다.** 이러한 종류의 알고리즘은 반복될 때마다 데이터의 양을 반으로 나눕니다. 만약 100개의 아이템이 있다면 답을 찾기위해 7단계를 거치게 되며, 1000개의 아이템에는 10단계, 그리고 1,000,000개의 아이템에서는 오직 20단계를 거치게됩니다.이 알고리즘은 많은 양의 데이터가 있더라고 매우 빠릅니다. 예: 이진탐색(binary search).
**O(n)** | linear | **좋은 편입니다.** 100개의 아이템이 있다면, 100개 단위의 일을 하며. 아이템이 두배가 된다면 정확히 두배 단위의 일을 하게 됩니다. (200단위의 일을 함). 예: 순차 탐색(sequential search).
**O(n log n)** | "linearithmic" | **적당합니다.** linear보다는 덜하지만 아주 나쁘진 않습니다. 예: the fastest general-purpose sorting algorithms.
**O(n^2)** | quadratic | **느립니다.** 만약 100개의 아이템이 있다면 100^2의 값인 10,000단위의 일을 합니다. 아이템의 개수가 두배가 되면 4배 더 느려집니다.(2의 제곱은 4이니까요). 예: insertion sort과 같이 nested loop를 사용하는 알고리즘.
**O(n^3)** | cubic | **형편없습니다.** 만약 100개의 아이템이 있다면 100^3인 1,000,000단위의 일을 합니다. 입력 값이 두배가 되면 8배 더 느린 성능을 냅니다. 예: matrix multiplication.
**O(2^n)** | exponential | **매우 형편없습니다.** 이런 종류의 알고리즘을 피하고싶겠지만 선택의 여지가 없을 때도 있습니다. 단순히 한 비트를 입력값에 더하면 실행 시간이 두배가 됩니다. 예: traveling salesperson problem.
**O(n!)** | factorial | **참을 수 없이 느립니다.** 한마디로 무언갈 할 떄 100만년이 걸린다고 보면 됩니다.

알고리즘이 어떤 Big-O인지 알아내는 작업에 수학이 자주 필요한 것은 아니지만, 어느정도 직감이 필요합니다. 만약 입력받은 값에서 모든 n개의 요소를 찾는 하나의 반복문을 실행하는 코드라면 그 알고리즘은  **O(n)** 입니다. 
만약 이중 반복문이라면 **O(n^2)**이며. 3중 반복문은 **O(n^3)**입니다.

Big-O 표기법은 추정치를 의미하며 실제로 ** n ** 값이 큰 경우에만 유용합니다. 예를들어   최악의 실행시간을 가지는 [insertion sort](Insertion%20Sort/) 알고리즘은 **O(n^2)**입니다. 이론상으로는 [merge sort](Merge%20Sort/)의 실행시간보다 나쁘지만 **O(n log n)**입니다. 데이터의 양은 적지만, insertion sort는 확실히 빠릅니다. 특히 배열이 이미 부분적으로 정렬이 되있다면요.

만약 이 내용이 혼란스럽다면 Big-O와 같은 것들로 너무 고통받지마세요
If you find this confusing, don't let this Big-O stuff bother you too much. 이것은 거의 두 개의 알고리즘을 비교해서 뭐가 더 적절한지 찾을때 유용하게 사용됩니다. 하지만 마지막에 그러나 결국 실제 가장 우수한 것을 실제로 시험하고 싶어할 것입니다. 그리고 데이터의 양이 비교적 적다면, 느린 알고리즘조차도 빠를 수 있습니다.
