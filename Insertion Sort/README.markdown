# 삽입 정렬

목표: 배열을 낮은쪽에서 높은쪽으로(또는 높은쪽에서 낮은쪽으로) 정렬할 수 있다.

당신은 숫자로 이루어진 배열이 주어져 있고, 알맞은 순서로 정렬을 해야합니다. 삽입 정렬 알고리즘은 다음과 같이 작동합니다:

숫자를 더미에 쌓습니다. 숫자더미들은 정렬되어있지않습니다.
숫자더미로부터 숫자를 고릅니다. 어떤 숫자를 고를지는 중요하지 않지만 가장 쉬운 방법은 숫자더미의 가장 위에 있는 숫자를 고르는 것입니다.
고른 숫자를 새로운 배열에 집어넣습니다.
다음 숫자를 정렬되지 않은 숫자더미에서 고르고 또 다시 새로운 배열에 집어 넣습니다. 그리고 처음 고른 숫자 뒤 또는 앞으로 방금 고른 숫자를 집어넣어 두 숫자가 정렬되도록합니다.
다시 숫자를 고르고 배열에 적절히 정렬된 위치에 넣어줍니다.
숫자더미에 더이상 숫자가 존재하지 않을 때까지 이 과정을 반복합니다. 그러면 빈 숫자더미와 정렬된 배열을 얻었을 것입니다.

숫자더미에서 숫자를 뽑아 배열의 적절히 정렬된 위치로 넣는다는것 때문에 “삽입" 정렬로 불립니다.

## 예제

`[ 8, 3, 5, 4, 6 ]` <— 이 숫자들이 정렬이 필요한 숫자라고 합시다. 이것은 정렬되지 않은 숫자더미입니다.

첫번째 숫자인 `8`을 고르고 새로운 배열에 넣어줍니다. 아직 배열이 없기때문에 이 작업은 쉽습니다. 그럼 정렬된 배열은 지금 `[ 8 ]`이며 숫자더미는 `[ 3, 5, 4, 6 ]` 입니다.

숫자더미에서 다음 숫자인 `3`을 고르고 방금 정렬돈 배열에 넣어줍니다. 이번 숫자는 `8` 앞으로 가야하기 때문에 이번에 정렬된 배열은 `[ 3, 8 ]`입니다. 그리고 숫자더미는 `[ 5, 4, 6 ]`입니다.

다음 숫자인 `5`를 뽑아 다시 정렬된 배열에 넣어줍니다. 이번 숫자는 `3`과 `8`사이에 넣어줍니다. 그러면 정렬된 배열은 현재 `[ 3, 5, 8 ]`이며, 숫자더미는 `[ 4, 6 ]`입니다.

숫자더미에서 숫자를 다 뽑을 때까지 이 작업을 반복합니다.

## 현재 위치 정렬

위의 설명대로라면 두개의 배열이 필요한 것처럼 보입니다. 하나는 정렬되지 않은 숫자더미이며 나머지 하나는 정렬된 숫서의 숫자들을 가지고있습니다.

하지만 분리된 배열을 만드는 대신 *현재 위치*를 참고하여 삽입 정렬을 사용 할 수 있습니다.
But you can perform the insertion sort *in-place*, without having to create a separate array. 단순히 배열을 하나하나 따라가며 어느부분이 정렬되어있고 어느부분이 정렬돼야할  숫자더미인지를 구분할 수 있습니다.

`[ 8, 3, 5, 4, 6 ]`라는 배열로 시작합시다. `|`는 정렬된부분의 끝과 정렬돼야할 숫자더미의 경계를 보여줍니다:

	[| 8, 3, 5, 4, 6 ]

위의 배열은 정렬된 부분이 비어있으며, 정렬돼야할 숫자더미가  `8`로 시작된다는것을 보여줍니다.
처음 숫자를 지나게 되면 다음과 같은 배열을 가지게됩니다:

	[ 8 | 3, 5, 4, 6 ]

정렬된 부분은 `[ 8 ]`이며 정렬돼야할 부분은 `[ 3, 5, 4, 6 ]`입니다. `|`가 한칸 오른족으로 이동되었습니다.

아래 배열들이 어떤식으로 정렬이 되는지를 보여줍니다:

	[| 8, 3, 5, 4, 6 ]
	[ 8 | 3, 5, 4, 6 ]
	[ 3, 8 | 5, 4, 6 ]
	[ 3, 5, 8 | 4, 6 ]
	[ 3, 4, 5, 8 | 6 ]
	[ 3, 4, 5, 6, 8 |]

각 단계에서  `|` 는 한칸씩 이동합니다. 위에서 볼수 있듯이 `|`가 이동하면서 배열이 정렬이 됩니다. 숫자더미는 숫자가 없고 더이상 정렬될 숫자가 없을 때까지 숫자 더미가 하나씩 줄어들고 정렬된 배열이 하나씩 증가합니다. 

## 어떻게 삽입할까요?

각 단계에서 정렬되지 않으 숫자더미의 가장 위에서부터 숫자를 집어 배열의 정렬된 부분에 집어넣습니다. 꼭 숫자를 적절한 부분에 위치시켜 배열의 시작부터 정렬되도록 하여야합니다. 그럼 어떻게 작동되는 걸까요?

그럼 처음 몇개의 요소가 아래와 같이 정렬되어 있다고 합시다:

	[ 3, 5, 8 | 4, 6 ]

다음 숫자는 `4`이며, 나머지 `[ 3, 5, 8 ]` 를 어딘가 정렬될 위치에 넣어야 합니다.

정렬하는 방법: `|`이전에 있는 숫자  `8`을 먼저 보세요. 

	[ 3, 5, 8, 4 | 6 ]
	        ^
	        
이 값이 `4`보다 큰가요? 맞습니다, 그래서 `4`는 `8` 앞으로 와야 합니다. 우리는 아래와 같은 배열을 얻기 위해 두 숫자의 위치를 바꿔줍니다:

	[ 3, 5, 4, 8 | 6 ]
	        <-->
	       자리 바뀜

아직 정렬해야할 부분이 남았습니다. 새로이 앞에 있는 값인 `5` 또한 `4` 보다 큽니다. 그래서 우리는 이 두 숫자 또한 자리를 바꿔주어야합니다.:

	[ 3, 4, 5, 8 | 6 ]
	     <-->
	    자리 바뀜

[추후 번역 예정]
다시 앞에 있는 값`3`이 `4`보다 큰가요? 아닙니다. 숫자 `4`로 자리 바꿈은 끝났습니다. 다시 배열의 앞부분은 정렬되었습니다.

위의 설명은 다음 섹션에서 보게 될 삽입 정렬 알고리즘의 내부 반복에 대한 것입니다. 이것은 숫자의 위치를 바꾸어주면서 그 위치로 숫자더미 가장 위에 있는 값을 넣어줍니다.

## 코드

아래 코드는 삽입 정렬은 Swift로 작성한 것입니다::

```swift
func insertionSort(_ array: [Int]) -> [Int] {
  var a = array                             // 1
  for x in 1..<a.count {                    // 2
    var y = x
    while y > 0 && a[y] < a[y - 1] {        // 3
      swap(&a[y - 1], &a[y])
      y -= 1
    }
  }
  return a
}
```

위의 코드를 플레이 그라운드에 넣고 아래와 같이 테스트해보세요:

```swift
let list = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]
insertionSort(list)
```

아래는 위의 코드가 어떻게 작동하는지에 대한 설명입니다..

1. 배열의 복사본을 만듭니다. 우리가 바로 `배열`의 값을 수정할 수 없기 때문에 이 과정이 필요합니다. 스위프트에 있는 `sort()`처럼 `insertionSort()` 함수도 원래 배열을 복사한 것을 정렬하여 반환합니다.

2. 이 함수에는 두개의 반복문이 있습니다. 바깥의 반복문은 매 턴마다 배열에 어떤 값이 있는지 봅니다. 이것은 숫자더미에서 가장 위에 있는 숫자를 가져와야 할지 보는 과정입니다. 변수 `x`는 정렬이 끝난 부분과 숫자 더미가 시작하는 부분의 인덱스입니다(위치를 `|`로 표시합니다.) . 0부터 `x`까지의 시작부분은 항상 정렬이 되어 있다는 것을 기억하세요 나머지 `x`부터 마지막 값들 까지는 정렬되지 않은 숫자더미입니다.

3. 안쪽 반복문은 `x` 위치에 어떤 값이 있는지를 봅니다. 그것은 숫자더미의 가장 위에 있는 값이며, 아마 전에 있던 값들보다는 작을 것입니다. 안쪽에 있는 배열은 단계별로 뒤를 밟아 뒤에 있는 값이 지금 값보다 큰지 비교하고 값을 바꿔줍니다.  안쪽 반복문이 다 완료되면 다시 배열의 앞부분은 정렬되며, 정렬된 값이 하나씩 늘어납니다.

> **Note:** 바깥에 있는 배열은 인덱스 0이 아닌 1에서 시작합니다. 숫자더미로부터 정렬될 배열의 가장 처음 값을 비교하는 것은 바뀌는 것이 없기 때문에 이 과정은 생략될 것입니다.

## 더이상의 자리바꿈은 없습니다.

위 버전의 삽입정렬은 잘 작동합니다. `swap()`함수를 호출 하는 과정을 지워줌으로써 속도를 조금 더 빠르게 만들 수 있습니다.

우리는 정렬된 배열에서 숫자를 다음 값과 바꾸는 것을 보았습니다.

	[ 3, 5, 8, 4 | 6 ]
	        <-->
            swap
	        
	[ 3, 5, 4, 8 | 6 ]
         <-->
	     swap

숫자를 앞에 있는 값과 계속 바꿔주는 대신 우리는 모든 값을 오른쪽으로 한칸씩 이동시켜주고, 새 숫자를 복사하여 오른쪽에 붙여줄 수 있습니다. Instead of swapping with each of the previous elements, we can just shift all those elements one position to the right, and then copy the new number into the right position.

	[ 3, 5, 8, 4 | 6 ]   4를 기억합니다.
	           *
	
	[ 3, 5, 8, 8 | 6 ]   8을 오른쪽으로 이동시킵니다.
	        --->
	        
	[ 3, 5, 5, 8 | 6 ]   5를 오른쪽으로 이동시킵니다.
	     --->
	     
	[ 3, 4, 5, 8 | 6 ]   4를 그 위치에 복사해줍니다.
	     *

코드는 다음과 같습니다:

```swift
func insertionSort(_ array: [Int]) -> [Int] {
  var a = array
  for x in 1..<a.count {
    var y = x
    let temp = a[y]
    while y > 0 && temp < a[y - 1] {
      a[y] = a[y - 1]                // 1
      y -= 1
    }
    a[y] = temp                      // 2
  }
  return a
}
```

주석`//1`은 앞에 있던 값이 오른쪽으로 이동하는 것을 보여줍니다. 안쪽 배열의 마지막 부분에 있는 `y`는 정렬된 위치에 있는 새로운 숫자의 목적지 인덱스이며, 주석`//2`는 그 숫자를 그 위치에 넣어줍니다.


## generic으로 표시하기

숫자 이외에 다른것들도 정렬하는게 좋을 수 있습니다. generic 배열의 데이터타입을 만들 수있고, 사용자를 도와주는 함수(또는 클로저)를 사용해 비교적 나은 성능을 낼 수 있습니다. 이 작업은 기존의 코드에서 두가지 요소를 바꾸는 것을 필요로합니다.

함수는 다음과 같이 변합니다:

```swift
func insertionSort<T>(_ array: [T], _ isOrderedBefore: (T, T) -> Bool) -> [T] {
```

배열의 타입은`[T]`이며 `T`는 generic을 위한 표시 기호입니다. 이제  `insertionSort()` 는 숫자든 문자열이든 그리고 그 어떤 타입의 배열이라도 수용할 수 있습니다.

`isOrderedBefore: (T, T) -> Bool`파라미터는  두 개의 `T`객체를 받고 첫번째 객체가 두번째 객체보다 앞이라면 true를 반환하며, 두번째 인자가 첫번째 인자보다 앞에 와야 한다면 false를 반환합니다. 이것이 정확히 Swift에 내장된 `sort()`가 하는 일입니다.

아래 코드에서 변한 부분은 안쪽 반복문에 있습니다:

```swift
      while y > 0 && isOrderedBefore(temp, a[y - 1]) {
```

`temp < a[y - 1]`를 쓰는 대신에, 우리는`isOrderedBefore()`함수를 호출합니다. 이제 기존함수에서 숫자 뿐만이 아닌 어떤 타입의 객체도 비교할 수 있다는 것을 제외하고는 똑같이 작동합니다.

플레이그라운드에서 테스트 해보시려면 다음 코드를 실행하세요:

```swift
let numbers = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]
insertionSort(numbers, <)
insertionSort(numbers, >)
```

`<` 와 `>` 는 정렬 순서를 낮은곳에서 높은곳으로 할지, 또는 높은곳에서 낮은곳으로 할지를 결정합니다.

물론 문자열도 정렬할 수 있습니다.

```swift
let strings = [ "b", "a", "d", "c", "e" ]
insertionSort(strings, <)
```

심지어 더 복잡한 객체들도 가능하죠:

```swift
let objects = [ obj1, obj2, obj3, ... ]
insertionSort(objects) { $0.priority < $1.priority }
```

클로져는 `insertionSort()`에게 객체의 `우선순위`를기준으로 정렬하라고 말하고 있습니다.

삽입 정렬은 *안정적인* 정렬입니다. 정렬은 요소들이 정렬된 이후에도 같은 관계를 가지는 정렬 키를 가지고 있을 때 안정적이라고 할 수 있습니다. 숫자와 문자열과 같은 단순한 값에는 중요하지 않지만 더 복잡한 객체에서 정렬을 할 때는 중요합니다. 위의 예제에서 만약 값에 관계없이 같은 `priority`를 가지고 있다면 그 두 객체는 위치가 바뀌지 않을 것입니다.

## 성능

삽입 정렬은 이미 배열이 정렬되어있다면 매우 빠릅니다. 말이 이상하게 들릴 수 있지만 모든 검색 알고리즘에서 항상 옳은 것은 아닙니다. 실제로 전체가 아니더라도 많은 데이터들이 많이 정렬되어있는 경우라면 삽입 정렬은 그래도 젛은 성능을 낼 것입니다.

삽입 정렬의 평균적인 그리고 최악의 성능은 **O(n^2)**입니다. 왜냐하면 이 함수에는 이중 반복문이 있기 때문입니다.퀵소트 및 병합 정렬과 같은 다른 알고리즘은 큰 입력 값에도 빠른 **O(n log n)**의 성능을 가지고 있습니다.

삽입 정렬은 작은 배열을 정렬 할 때는 매우 빠릅니다. 몇개의 표준 라이브러리는 분할(partition)사이즈가 10 미만일 경우에 퀵소트를 삽입 정렬로 바꿔주는 함수를 가지고 있습니다.

이 문서에서는 스위프트의 `sort()`와 우리의 `insertionSort()`를 비교해 보았습니다. 100개 정도의 아이템을 가진 배열에서의 차이는 별로 크지 않습니다.  하지만, 입력 값이 커질수록 **O(n^2)**는 최악의 경우 **O(n log n)**의 성능을 내기 시작하고, 삽입정렬은 더이상 이것을 커버하지 못합니다.

## 이것도 봐보세요

[Wikipedia에 설명되어 있는 Insertion sort](https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)

*이 글은 Swift Algorithm Club을 위해 Matthijs Hollemans에 의해 작성되었습니다.*
